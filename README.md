# MySQL

## InnoDB引擎

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

## 索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样

### B+Tree原理

#### 数据结构

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png)

#### 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

### B+Tree 索引

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的

每一个索引在InnoDB里面对应一棵B+树，假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下

<img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:50%;" />

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引

#### 聚簇索引

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为**聚簇索引（clustered index）**

#### 二级索引

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为**二级索引（secondary index）**

#### 聚簇索引和二级索引的查询区别

- 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为【回表】

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询

### 自适应哈希索引

哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表

假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示

<img src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" alt="img" style="zoom:50%;" />

自适应哈希索引是数据库自身创建并使用的，DBA本身不能干预，Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

自适应哈希索引经哈希函数映射到一个哈希表中， 因此哈希表这种结构适用于只有等值查询的场景，对于字典类型的查找非常快速， 如SELECT*FROM TABLE WHERE index_col=‘xxx’ 。但是对于范围查找就无能为力了

### 索引优化

当查询结果所需要的数据只在主键索引上有，所以不得不回表（回到主键索引树搜索）。那么，有没有可能经过索引优化，避免回表过程？

#### 覆盖索引

如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段

#### 最左前缀原则

如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？

B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录

我们用（name，age）这个联合索引来分析

<img src="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img" style="zoom:50%;" />



## 锁

## 事务

### 概念

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚

MySQL 默认采用自动提交模式。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交

### ACID (原子性、一致性、隔离性、持久性)

#### **原子性(Atomicity)**

事务的所有操作要么全部提交成功，要么全部失败回滚，像一个整体，不能从中间打断

#### **一致性(Consistency)**

数据库在事务执行前后都保持一致性状态

#### **隔离性(Isolation)**

多个事务同时执行的时候，不互相干扰。不同的隔离级别，互相独立的程度不同 

#### **持久性(Durability)**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失

### 事务隔离等级 & 并发一致性问题

MySQL 默认的事务隔离级别是可重复读(REPEATABLE READ)

#### **未提交读(READ UNCOMMITTED) & 脏读**

可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚

因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为【脏读】

#### **提交读(READ COMMITTED) & 不可重复读**

能读取到已经提交事务的数据，因此它不会有脏读问题。

但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做【不可重复读】

#### **可重复读(REPEATABLE READ) & 幻读**

表示同一事务中，对一个数据读取的值，永远跟第一次读取的值一致，不受其他事务中数据操作的影响。

但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，这时候当前事务在前后两次查询同一范围的时候，后一次查询看到了前一次没有看到的行，这就是【幻读】，幻读是读取了其他事务新增的数据，而且后一次查询用的是`当前读`(select * from xxx where for update)，普通查询的`快照读`是出现不了幻读的，而且幻读专指`新插入的行`，当前事务看到了就好象发生了幻觉一样，数据被修改不能称为幻读

#### **可串行化(SERIALIZABLE)**

序列化，事务最高隔离级别，表示任何一个事务，一旦对某一个数据进行了任何操作，一直到这个事务结束，MySQL都会把这个数据锁住，禁止其他事务对这个数据进行任何操作。它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多

总结一下，MySQL 的 4 种事务隔离级别对应脏读、不可重复读和幻读的关系如下

![img](https://s6.51cto.com/oss/202201/03/03f9024f847f83348a961b9d7eef0687.png)

### MVCC (多版本并发控制、事务隔离的实现)

多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式， 是通过保存数据在某个时间点的快照来实现并发控制的，可以认为是行级锁的变种

多版本并发控制的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果

用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现

#### 当前读和快照读 (一致性读)

mysql读取数据实际上有两种读取模式：当前读和快照读，使用 MVCC 读取的是快照中的数据

**当前读**：每次读取的都是当前最新的数据，但是读的时候不允许写，写的时候也不允许读，以下情况属于当前读

- 读锁（S锁，共享锁）

  ```mysql
  select k from t where id=1 lock in share mode;
  ```

- 写锁（X锁，排他锁）

  ```mysql
  select k from t where id=1 for update;
  ```

- update , delete , insert语句

**快照读 (一致性读)**：读写不冲突，读取的是记录数据的可见版本（可能是过期的数据），不用加锁

- 隔离级别Repeatable Read（默认隔离级别）：

  start transaction命令（并不是一个事务的起点）执行后要再等到执行第一个select语句时才创建快照，start transaction with consistent snapshot 命令代表事务立刻启动，快照也会立刻创建

- 隔离级别Read Committed：

  每次select都生成一个快照读，这时候快照读和当前读读取的数据是一样的，都是最新的

#### undolog

在innodb引擎下的表，每个数据行都有隐藏的两列，一列是trx_id，也就是更新（insert、update、delete）这条记录的事务ID；一列是roll_pointer回滚指针，指向上次修改的指针，如果是新增的则为null；如果不存在主键的话，还会有第三列row_id，在没有主键的情况下默认生成的主键

![InnoDB数据记录隐藏列](https://segmentfault.com/img/bVbyzVU)

实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。当一个旧的事务需要读取数据时，为了能够读取到老版本的数据，需要顺着undo列找到满足其可见性的记录

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到

<img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" alt="img" style="zoom: 42%;" /><img src="https://segmentfault.com/img/bVbyzV9" alt="Undo Log回滚历史记录" style="zoom:65%;" />

#### 一致性读视图 read-view & MVCC的实现

一致性读视图没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它

也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id

<img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" alt="img" style="zoom:50%;" />

图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25

InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。

数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位，这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）

而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的

<img src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" alt="img" style="zoom:50%;" />

这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：

- 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的
- 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的
- 如果落在黄色部分，那就包括两种情况
  - 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见
  - 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见

如果某个版本的数据对当前事务是不可见的，那么就要顺着回滚指针继续查找下个版本，直到找到可见的版本











































